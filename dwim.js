// Generated by CoffeeScript 1.7.1
(function() {
  var Dwim, DwimState, keymap, mode_keymap, parseRanges, reverseDir,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.UP = {
    theta: Math.PI / 2,
    dx: 0,
    dy: -1,
    name: 'up'
  };

  window.LEFT = {
    theta: Math.PI,
    dx: -1,
    dy: 0,
    name: 'left'
  };

  window.RIGHT = {
    theta: 0,
    dx: 1,
    dy: 0,
    name: 'right'
  };

  window.DOWN = {
    theta: -Math.PI / 2,
    dx: 0,
    dy: 1,
    name: 'down'
  };

  keymap = {
    'w': UP,
    'a': LEFT,
    's': DOWN,
    'd': RIGHT,
    '<up>': UP,
    '<left>': LEFT,
    '<down>': DOWN,
    '<right>': RIGHT
  };

  mode_keymap = {
    '1': 0,
    '2': 1,
    '3': 2,
    '4': 3
  };

  reverseDir = function(dir) {
    switch (dir) {
      case UP:
        return DOWN;
      case DOWN:
        return UP;
      case LEFT:
        return RIGHT;
      case RIGHT:
        return LEFT;
    }
  };

  parseRanges = function(ranges_string) {
    var d, i, point_list, range, rangex, rangey, x, y, _i, _j, _k, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    point_list = [];
    _ref = ranges_string.split(' ');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      range = _ref[_i];
      _ref1 = (function() {
        var _j, _len1, _ref1, _results;
        _ref1 = range.split(',');
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          d = _ref1[_j];
          if (d.indexOf('-') === -1) {
            i = parseInt(d, 10);
            _results.push([i, i]);
          } else {
            i = d.split('-');
            _results.push([parseInt(i[0], 10), parseInt(i[1], 10)]);
          }
        }
        return _results;
      })(), rangex = _ref1[0], rangey = _ref1[1];
      for (x = _j = _ref2 = rangex[0], _ref3 = rangex[1]; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; x = _ref2 <= _ref3 ? ++_j : --_j) {
        for (y = _k = _ref4 = rangey[0], _ref5 = rangey[1]; _ref4 <= _ref5 ? _k <= _ref5 : _k >= _ref5; y = _ref4 <= _ref5 ? ++_k : --_k) {
          point_list.push({
            x: x,
            y: y
          });
        }
      }
    }
    return point_list;
  };

  DwimState = (function() {
    function DwimState(level) {
      var id, idx, mode, obstacle, program, x, y, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _o, _p, _q, _ref, _ref1, _ref10, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      this.Wi = level.dims.w;
      this.Hi = level.dims.h;
      this.bot = {
        x: level.startpos.x,
        y: level.startpos.y
      };
      this.level = {};
      for (x = _i = -1, _ref = this.Wi; -1 <= _ref ? _i <= _ref : _i >= _ref; x = -1 <= _ref ? ++_i : --_i) {
        this.level[x] = {};
        for (y = _j = -1, _ref1 = this.Hi; -1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = -1 <= _ref1 ? ++_j : --_j) {
          this.level[x][y] = {
            type: 'empty'
          };
        }
      }
      for (x = _k = -1, _ref2 = this.Wi; -1 <= _ref2 ? _k <= _ref2 : _k >= _ref2; x = -1 <= _ref2 ? ++_k : --_k) {
        this.level[x][-1] = {
          type: 'obstacle',
          id: 0
        };
        this.level[x][this.Hi] = {
          type: 'obstacle',
          id: 0
        };
      }
      for (y = _l = -1, _ref3 = this.Hi; -1 <= _ref3 ? _l <= _ref3 : _l >= _ref3; y = -1 <= _ref3 ? ++_l : --_l) {
        this.level[-1][y] = {
          type: 'obstacle',
          id: 0
        };
        this.level[this.Wi][y] = {
          type: 'obstacle',
          id: 0
        };
      }
      this.obstacles = [{}];
      _ref4 = level.obstacles;
      for (_m = 0, _len = _ref4.length; _m < _len; _m++) {
        obstacle = _ref4[_m];
        id = this.obstacles.length;
        this.obstacles[id] = obstacle;
        _ref5 = parseRanges(obstacle);
        for (_n = 0, _len1 = _ref5.length; _n < _len1; _n++) {
          _ref6 = _ref5[_n], x = _ref6.x, y = _ref6.y;
          if (this.level[x][y].type === 'obstacle' && this.level[x][y].id === 0) {
            throw 'overwriting border with lesser obstacle';
          }
          this.level[x][y] = {
            type: 'obstacle',
            id: id
          };
        }
      }
      this.programs = [];
      _ref7 = level.programs;
      for (_o = 0, _len2 = _ref7.length; _o < _len2; _o++) {
        program = _ref7[_o];
        id = this.programs.length;
        this.programs[id] = program;
        _ref8 = parseRanges(program.loc);
        for (_p = 0, _len3 = _ref8.length; _p < _len3; _p++) {
          _ref9 = _ref8[_p], x = _ref9.x, y = _ref9.y;
          if (this.level[x][y].type === 'obstacle' && this.level[x][y].id === 0) {
            throw 'overwriting border with program';
          }
          this.level[x][y] = {
            type: 'program',
            id: id
          };
        }
      }
      if (this.level[level.exitpos.x][level.exitpos.y].type === 'obstacle' && this.level[level.exitpos.x][level.exitpos.y].id === 0) {
        throw 'overwriting border with exit';
      }
      this.level[level.exitpos.x][level.exitpos.y] = {
        type: 'exit'
      };
      this.modes = level.mappings;
      _ref10 = this.modes;
      for (idx = _q = 0, _len4 = _ref10.length; _q < _len4; idx = ++_q) {
        mode = _ref10[idx];
        mode.idx = idx;
      }
      this.current_mode = this.modes[0];
      this.current_program = [];
      this.current_program_id = -1;
    }

    DwimState.prototype.requestBotMove = function(dir) {
      var dest, dest_block;
      dest = {
        x: this.bot.x + dir.dx,
        y: this.bot.y + dir.dy
      };
      dest_block = this.level[dest.x][dest.y];
      if (dest_block.type === 'obstacle') {
        return false;
      }
      this.bot.x = dest.x;
      this.bot.y = dest.y;
      this.loadProgram();
      if (dest_block.type === 'exit') {
        this.halted = true;
        this.won = true;
      }
      return true;
    };

    DwimState.prototype.loadProgram = function() {
      var block;
      block = this.level[this.bot.x][this.bot.y];
      if (block.type === 'program') {
        if (this.current_program.length === 0) {
          this.current_program = this.programs[block.id].code.split('');
          return this.current_program_id = block.id;
        }
      }
    };

    DwimState.prototype.mappingLookup = function(mode, symbol) {
      if (symbol in mode.lookup) {
        return mode.lookup[symbol];
      } else {
        return null;
      }
    };

    DwimState.prototype.mappingInsert = function(mode, symbol, command) {
      mode.lookup[symbol] = command;
      if (!(__indexOf.call(mode.symbols, symbol) >= 0)) {
        return mode.symbols.push(symbol);
      }
    };

    DwimState.prototype.doWhatMustBeDone = function() {
      var command, success, symbol;
      if (this.current_program.length === 0) {
        return {
          success: false,
          move: null
        };
      }
      symbol = this.current_program.shift();
      command = this.mappingLookup(this.current_mode, symbol);
      if (command === null) {
        this.current_program.unshift(symbol);
        return {
          success: false,
          move: null
        };
      }
      if (command.type === 'move') {
        success = this.requestBotMove(command.dir);
      } else {
        success = true;
        this.current_mode = this.modes[command.idx];
        this.loadProgram();
      }
      if (!success) {
        this.current_program.unshift(symbol);
      }
      return {
        success: success,
        move: command
      };
    };

    DwimState.prototype.insertNeededMapping = function(new_command) {
      var command, symbol;
      if (this.current_program.length === 0) {
        return false;
      }
      symbol = this.current_program[0];
      command = this.mappingLookup(this.current_mode, symbol);
      if (command !== null) {
        return false;
      }
      this.mappingInsert(this.current_mode, symbol, new_command);
      return true;
    };

    return DwimState;

  })();

  Dwim = (function() {
    function Dwim(parent_div, level, level_id, control_scheme) {
      var gfx;
      this.parent_div = parent_div;
      this.level = level;
      this.level_id = level_id;
      this.control_scheme = control_scheme;
      this.mouseCB = __bind(this.mouseCB, this);
      this.keyboardCB = __bind(this.keyboardCB, this);
      this.render = __bind(this.render, this);
      this.state = new DwimState(this.level);
      gfx = this.gfx = new window.DwimGraphics(this.parent_div, this.state);
      this.bot_sprite = this.gfx.makeBotSprite();
      this.gfx.sprites.push(this.bot_sprite);
      this.mode_sprites = this.gfx.makeModeSprites();
      this.gfx.sprites = this.gfx.sprites.concat(this.mode_sprites);
      this.clues_sprite = this.gfx.makeCluesSprite();
      this.gfx.sprites.push(this.clues_sprite);
      this.down_keys = {};
    }

    Dwim.prototype.startRender = function() {
      var rendering;
      if (this.control_scheme === 'keyboard') {
        registerKeyFunction(this.keyboardCB);
      }
      if (this.control_scheme === 'mouse') {
        registerMouseFunction(this.gfx.cnv, this.mouseCB);
      }
      requestAnimationFrame(this.render);
      return rendering = true;
    };

    Dwim.prototype.render = function(absolute_t) {
      if (this.state.halted) {
        if (this.state.won) {
          this.linkNextLevel();
        } else {
          this.linkSameLevel();
        }
      }
      this.gfx.render(absolute_t);
      this.processProgram();
      if (this.gfx.isAnimating()) {
        requestAnimationFrame(this.render);
        return this.rendering = true;
      } else {
        this.gfx.render(absolute_t);
        return this.rendering = false;
      }
    };

    Dwim.prototype.keyboardCB = function(key, keyupdown, keydown) {
      var mode, move;
      if (this.state.halted) {
        return;
      }
      if (keyupdown) {
        if (this.down_keys[key]) {
          if (!keydown) {
            this.down_keys[key] = false;
          }
          return;
        }
        this.down_keys[key] = keydown;
        if (!keydown) {
          return;
        }
      }
      if (key in keymap) {
        move = keymap[key];
        this.processPlayerMove(move);
      } else if (key in mode_keymap) {
        mode = mode_keymap[key];
        this.processModeChange(mode);
      }
      if (!this.rendering) {
        requestAnimationFrame(this.render);
        return this.rendering = true;
      }
    };

    Dwim.prototype.mouseCB = function(what, where) {
      var handled, idx, ma, midx, midy, theta, xmax, xmin, ymax, ymin, _i, _len, _ref;
      if (what !== 'click') {
        return;
      }
      if (this.gfx.isAnimating()) {
        return;
      }
      handled = false;
      _ref = this.gfx.mode_appearance;
      for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
        ma = _ref[idx];
        xmin = ma.x + this.gfx.mode_dims.x;
        xmax = xmin + this.gfx.block * 2;
        ymin = ma.y + this.gfx.mode_dims.y;
        ymax = ymin + this.gfx.block * 6;
        if (where.x >= xmin && where.y >= ymin && where.x < xmax && where.y < ymax) {
          this.processModeChange(idx);
          handled = true;
          break;
        }
      }
      if (!handled && where.x >= this.gfx.board_dims.x && where.x < this.gfx.board_dims.x + this.gfx.board_dims.width && where.y >= this.gfx.board_dims.y && where.y < this.gfx.board_dims.y + this.gfx.board_dims.height) {
        midx = this.gfx.board_dims.x + this.gfx.board_dims.width / 2;
        midy = this.gfx.board_dims.y + this.gfx.board_dims.height / 2;
        if (midx * midx + midy * midy > this.gfx.block * 3) {
          theta = Math.atan2(where.y - midy, where.x - midx);
          handled = true;
          if (theta < -Math.PI * .75 || theta > Math.PI * .75) {
            this.processPlayerMove(LEFT);
          } else if (theta < -Math.PI * .25) {
            this.processPlayerMove(UP);
          } else if (theta < Math.PI * .25) {
            this.processPlayerMove(RIGHT);
          } else {
            this.processPlayerMove(DOWN);
          }
        }
      }
      if (!this.rendering) {
        requestAnimationFrame(this.render);
        return this.rendering = true;
      }
    };

    Dwim.prototype.processPlayerMove = function(move) {
      var old_pos;
      if (this.state.current_program.length > 0) {
        if (!this.state.insertNeededMapping({
          type: 'move',
          dir: move
        })) {
          return;
        }
        return this.processProgram();
      } else {
        old_pos = this.bot_sprite.computePos();
        if (this.state.requestBotMove(move)) {
          return this.bot_sprite.animateMove(old_pos, move);
        } else {
          return this.bot_sprite.animateBump(old_pos, move);
        }
      }
    };

    Dwim.prototype.processModeChange = function(mode_idx) {
      if (mode_idx === this.state.current_mode.idx) {
        return;
      }
      if (mode_idx >= this.state.modes.length) {
        return;
      }
      if (this.state.current_program.length > 0) {
        if (!this.state.insertNeededMapping({
          type: 'mode',
          idx: mode_idx
        })) {
          return;
        }
        return this.processProgram();
      } else {
        this.state.current_mode = this.state.modes[mode_idx];
        this.gfx.animatePopIn(this.mode_sprites[mode_idx].animations, 1, 1);
        return this.gfx.animatePopIn(this.bot_sprite.animations, 1, 1);
      }
    };

    Dwim.prototype.processProgram = function() {
      var move, new_pos, old_pos, old_prog, success, _ref;
      if (!this.gfx.isAnimating() && this.state.current_program.length > 0 && !this.state.halted) {
        old_pos = this.bot_sprite.computePos();
        old_prog = this.state.current_program;
        this.clues_sprite.program_id = this.state.current_program_id;
        this.clues_sprite.program_idx = this.state.programs[this.state.current_program_id].code.length - this.state.current_program.length;
        _ref = this.state.doWhatMustBeDone(), success = _ref.success, move = _ref.move;
        if (success) {
          new_pos = this.bot_sprite.computePos();
          if (old_pos.x !== new_pos.x || old_pos.y !== new_pos.y) {
            this.bot_sprite.animateMove(old_pos, move.dir);
          } else if (move.type === 'mode') {
            this.gfx.animatePopIn(this.mode_sprites[move.idx].animations, 1, 1);
            this.gfx.animatePopIn(this.bot_sprite.animations, 1, 1);
          }
          return this.gfx.onAnimComplete((function(_this) {
            return function() {
              return _this.clues_sprite.program_id = -1;
            };
          })(this));
        } else if (move !== null) {
          this.bot_sprite.animateBump(old_pos, move.dir);
          return this.state.halted = true;
        }
      }
    };

    Dwim.prototype.linkNextLevel = function() {
      var link;
      if (this.linked_next_level) {
        return;
      }
      this.linked_next_level = true;
      this.parent_div.removeChild(this.gfx.cnv);
      link = document.createElement('a');
      link.href = "?" + this.level.next_level;
      link.appendChild(this.gfx.cnv);
      return this.parent_div.appendChild(link);
    };

    Dwim.prototype.linkSameLevel = function() {
      var link;
      if (this.linked_same_level) {
        return;
      }
      this.linked_same_level = true;
      this.parent_div.removeChild(this.gfx.cnv);
      link = document.createElement('a');
      link.href = "?" + this.level_id;
      link.appendChild(this.gfx.cnv);
      return this.parent_div.appendChild(link);
    };

    return Dwim;

  })();

  window.Dwim = Dwim;

}).call(this);

//# sourceMappingURL=dwim.map
