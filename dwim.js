// Generated by CoffeeScript 1.7.1
(function() {
  var DOWN, Dwim, LEFT, Mapping, MappingCommand, MoveCommand, RIGHT, UP, board_start, g, instruction_names, keymap, mapping_start, menu_start, menu_width, parseRanges, program_start, reverseDir,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  UP = {
    theta: Math.PI / 2,
    dx: 0,
    dy: -1
  };

  LEFT = {
    theta: Math.PI,
    dx: -1,
    dy: 0
  };

  RIGHT = {
    theta: 0,
    dx: 1,
    dy: 0
  };

  DOWN = {
    theta: -Math.PI / 2,
    dx: 0,
    dy: 1
  };

  keymap = {
    'w': UP,
    'a': LEFT,
    's': DOWN,
    'd': RIGHT,
    '<up>': UP,
    '<left>': LEFT,
    '<down>': DOWN,
    '<right>': RIGHT
  };

  reverseDir = function(dir) {
    switch (dir) {
      case UP:
        return DOWN;
      case DOWN:
        return UP;
      case LEFT:
        return RIGHT;
      case RIGHT:
        return LEFT;
    }
  };

  g = window.dwim_graphics;

  instruction_names = {
    s: 'square',
    c: 'circle',
    d: 'diamond',
    h: 'hex'
  };

  board_start = {
    x: 70,
    y: 168
  };

  program_start = {
    x: 20,
    y: 32
  };

  mapping_start = {
    x: 90,
    y: 10
  };

  menu_start = {
    x: 190,
    y: 10
  };

  menu_width = 140;

  parseRanges = function(ranges_string) {
    var d, i, point_list, range, rangex, rangey, x, y, _i, _j, _k, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    point_list = [];
    _ref = ranges_string.split(' ');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      range = _ref[_i];
      _ref1 = (function() {
        var _j, _len1, _ref1, _results;
        _ref1 = range.split(',');
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          d = _ref1[_j];
          if (d.indexOf('-') === -1) {
            i = parseInt(d, 10);
            _results.push([i, i]);
          } else {
            i = d.split('-');
            _results.push([parseInt(i[0], 10), parseInt(i[1], 10)]);
          }
        }
        return _results;
      })(), rangex = _ref1[0], rangey = _ref1[1];
      for (x = _j = _ref2 = rangex[0], _ref3 = rangex[1]; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; x = _ref2 <= _ref3 ? ++_j : --_j) {
        for (y = _k = _ref4 = rangey[0], _ref5 = rangey[1]; _ref4 <= _ref5 ? _k <= _ref5 : _k >= _ref5; y = _ref4 <= _ref5 ? ++_k : --_k) {
          point_list.push({
            x: x,
            y: y
          });
        }
      }
    }
    return point_list;
  };

  Dwim = (function() {
    function Dwim(cnv, status1, status2) {
      this.cnv = cnv;
      this.keyboardCB = __bind(this.keyboardCB, this);
      this.renderCB = __bind(this.renderCB, this);
      this.ctx = this.cnv.getContext('2d');
      this.W = this.cnv.width;
      this.H = this.cnv.height;
      this.Wi = Math.floor(this.W / g.cell_size);
      this.Hi = Math.floor(this.H / g.cell_size);
      this.status_div = [status1, status2];
    }

    Dwim.prototype.start = function(level) {
      var id, obstacle, program, x, y, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      this.botx = level.startpos.x;
      this.boty = level.startpos.y;
      if (level.startpos.dir != null) {
        this.botdir = level.startpos.dir.theta;
      } else {
        this.botdir = RIGHT.theta;
      }
      this.Wi = level.dims.w;
      this.Hi = level.dims.h;
      this.cnv.width = this.W = board_start.x + this.Wi * g.cell_size;
      this.cnv.height = this.H = board_start.y + this.Hi * g.cell_size;
      this.ctx = this.cnv.getContext('2d');
      this.level = [];
      for (x = _i = 0, _ref = this.Wi; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        this.level[x] = [];
        for (y = _j = 0, _ref1 = this.Hi; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          this.level[x][y] = {
            type: 'empty'
          };
        }
      }
      this.obstacles = [];
      _ref2 = level.obstacles;
      for (_k = 0, _len = _ref2.length; _k < _len; _k++) {
        obstacle = _ref2[_k];
        id = this.obstacles.length;
        this.obstacles[id] = obstacle;
        _ref3 = parseRanges(obstacle);
        for (_l = 0, _len1 = _ref3.length; _l < _len1; _l++) {
          _ref4 = _ref3[_l], x = _ref4.x, y = _ref4.y;
          this.level[x][y] = {
            type: 'obstacle',
            id: id
          };
        }
      }
      this.programs = [];
      _ref5 = level.programs;
      for (_m = 0, _len2 = _ref5.length; _m < _len2; _m++) {
        program = _ref5[_m];
        id = this.programs.length;
        this.programs[id] = program;
        _ref6 = parseRanges(program.loc);
        for (_n = 0, _len3 = _ref6.length; _n < _len3; _n++) {
          _ref7 = _ref6[_n], x = _ref7.x, y = _ref7.y;
          this.level[x][y] = {
            type: 'program',
            id: id
          };
        }
      }
      this.level[level.exitpos.x][level.exitpos.y] = {
        type: 'exit'
      };
      this.available_mappings = level.available_mappings;
      this.active_program = null;
      this.allowed_move = null;
      this.mappings = [new Mapping(0)];
      this.active_mapping = null;
      this.next_level_id = level.next_level;
      this.mapping_menu = null;
      this.requestRender();
      this.startInput();
      return this.updateProgram();
    };

    Dwim.prototype.requestRender = function() {
      return requestAnimationFrame(this.renderCB);
    };

    Dwim.prototype.startInput = function() {
      return registerKeyFunction(this.keyboardCB);
    };

    Dwim.prototype.setStatus = function(status1, status2) {
      if (status1 != null) {
        this.status_div[0].innerHTML = status1;
      }
      if (status2 != null) {
        return this.status_div[1].innerHTML = status2;
      }
    };

    Dwim.prototype.setError = function(error) {
      return this.setStatus('<span class="error">Error</a>', '<span class="error">' + error + '</span>');
    };

    Dwim.prototype.nextLevelLink = function() {
      return this.setStatus('Completed!', "<a href=\"?" + this.next_level_id + "\">Next Level</a>");
    };

    Dwim.prototype.renderCB = function() {
      var code, cs, heading_measure, height, ics, idx, len, msg, x, y, _i, _j, _k, _l, _len, _ref, _ref1, _ref2, _ref3;
      g.clear(this.ctx, this.W, this.H);
      this.ctx.save();
      this.ctx.translate(board_start.x, board_start.y);
      for (x = _i = 0, _ref = this.Wi; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        for (y = _j = 0, _ref1 = this.Hi; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          switch (this.level[x][y].type) {
            case 'empty':
              true;
              break;
            case 'program':
              this.renderProgramCell(x, y);
              break;
            case 'obstacle':
              this.renderObstacleCell(x, y);
              break;
            case 'exit':
              this.renderExitCell(x, y);
          }
        }
      }
      g.renderBot(this.ctx, (this.botx + .5) * g.cell_size, (this.boty + .5) * g.cell_size, this.botdir);
      this.ctx.translate(-.5, -.5);
      g.border(this.ctx, this.Wi * g.cell_size, this.Hi * g.cell_size);
      this.ctx.restore();
      if (this.active_program != null) {
        this.ctx.save();
        this.ctx.translate(program_start.x, program_start.y);
        code = this.active_program.code;
        cs = g.command_size;
        ics = g.inner_command_size;
        this.ctx.save();
        g.setStyle(this.ctx, g.thick_lined_style);
        this.ctx.translate(cs / 2, cs / 2 - this.pc * cs);
        for (idx = _k = 0, _ref2 = code.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; idx = 0 <= _ref2 ? ++_k : --_k) {
          g.renderShape(this.ctx, instruction_names[code[idx]], ics / 2);
          this.ctx.translate(0, cs);
        }
        this.ctx.restore();
        this.ctx.save();
        g.setStyle(this.ctx, g.lined_style);
        this.ctx.strokeRect(0, 0, cs, cs);
        this.ctx.restore();
        this.ctx.restore();
      }
      if (this.active_mapping != null) {
        this.ctx.save();
        this.ctx.translate(mapping_start.x, mapping_start.y);
        this.active_mapping.render(this.ctx, this.currentInstruction());
        this.ctx.restore();
      }
      if (this.mapping_menu != null) {
        len = this.mapping_menu.entries.length;
        this.ctx.save();
        this.ctx.translate(menu_start.x, menu_start.y);
        g.setStyle(this.ctx, g.lined_style);
        height = (len + 1) * g.menu_text_spacing + 32;
        this.ctx.fillRect(0, 0, menu_width, height);
        this.ctx.strokeRect(0, 0, menu_width, height);
        g.setStyle(this.ctx, g.menu_text_style);
        this.ctx.translate(16, 16 + g.menu_text_spacing / 2);
        g.setStyle(this.ctx, g.menu_text_style);
        this.ctx.fillText('Switch to:', 0, 0);
        heading_measure = this.ctx.measureText('Switch to:');
        g.setStyle(this.ctx, g.lined_style);
        this.ctx.beginPath();
        this.ctx.moveTo(0, g.menu_text_spacing / 2 - 4);
        this.ctx.lineTo(heading_measure.width, g.menu_text_spacing / 2 - 4);
        this.ctx.stroke();
        g.setStyle(this.ctx, g.menu_text_style);
        _ref3 = this.mapping_menu.entries;
        for (idx = _l = 0, _len = _ref3.length; _l < _len; idx = ++_l) {
          msg = _ref3[idx];
          this.ctx.translate(0, g.menu_text_spacing);
          this.ctx.fillText(msg.name, 0, 0);
        }
        g.renderBot(this.ctx, -16, (this.mapping_menu.selected - len + 1) * g.menu_text_spacing, RIGHT.theta);
        g.renderBot(this.ctx, menu_width - 16, (this.mapping_menu.selected - len + 1) * g.menu_text_spacing, LEFT.theta);
        this.ctx.restore();
        return this.setStatus(null, 'Input: up/down to move selection, &lt;enter&gt; to select');
      }
    };

    Dwim.prototype.keyboardCB = function(key) {
      var dir;
      this.requestRender();
      if (this.stop_running) {
        return;
      }
      if (this.mapping_menu) {
        if (key in keymap) {
          dir = keymap[key];
          if (dir === UP) {
            this.mapping_menu.selected = Math.max(0, this.mapping_menu.selected - 1);
          }
          if (dir === DOWN) {
            this.mapping_menu.selected = Math.min(this.mapping_menu.entries.length - 1, this.mapping_menu.selected + 1);
          }
        }
        if (key === '<return>') {
          this.requestMappingChange();
        }
        if (key === '<backspace>') {
          this.mapping_menu = null;
        }
      } else {
        if (key in keymap) {
          dir = keymap[key];
          this.requestBotMove(dir);
        }
        if (key === 'm') {
          this.showMappingChangeMenu();
        }
        if (key === '<return>') {
          this.doWhatMustBeDone();
        }
      }
    };

    Dwim.prototype.renderProgramCell = function(x, y) {
      return g.renderProgramCell(this.ctx, x, y);
    };

    Dwim.prototype.renderObstacleCell = function(x, y) {
      return g.renderObstacleCell(this.ctx, x, y);
    };

    Dwim.prototype.renderExitCell = function(x, y) {
      return g.renderExitCell(this.ctx, x, y);
    };

    Dwim.prototype.updateAllowedMove = function() {
      var action;
      if (this.active_program == null) {
        this.allowed_move = null;
        return;
      }
      this.allowed_move = {
        x: -1,
        y: -1
      };
      action = this.translateInstruction(this.currentInstruction());
      if (action.type === 'move') {
        this.allowed_move = {
          x: this.botx + action.dir.dx,
          y: this.boty + action.dir.dy
        };
      }
      if (action.type === 'blank') {
        this.allowed_move = null;
      }
    };

    Dwim.prototype.isMoveAllowed = function(x, y) {
      if (x < 0 || y < 0 || x >= this.Wi || y >= this.Hi) {
        return false;
      }
      if (this.level[x][y].type === 'obstacle') {
        return false;
      }
      if (this.allowed_move != null) {
        if (this.allowed_move.x !== x || this.allowed_move.y !== y) {
          return false;
        }
      }
      return true;
    };

    Dwim.prototype.requestBotMove = function(dir) {
      var x, y;
      x = this.botx + dir.dx;
      y = this.boty + dir.dy;
      if (this.isMoveAllowed(x, y)) {
        if (this.active_program != null) {
          if (this.isCurrentActionBlank()) {
            this.execute({
              type: 'move',
              dir: dir
            });
          }
        } else {
          this.botx = x;
          this.boty = y;
          this.botdir = dir.theta;
          this.updateProgram();
        }
      } else if (this.active_program == null) {
        this.botdir = dir.theta;
      }
    };

    Dwim.prototype.showMappingChangeMenu = function() {
      var idx, map, mapname, _i, _j, _len, _len1, _ref, _ref1, _results;
      if (this.isCurrentActionBlank() && this.available_mappings.length > 0) {
        this.mapping_menu = {
          selected: 0,
          entries: []
        };
        _ref = this.mappings;
        for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
          map = _ref[idx];
          if (map !== this.active_mapping) {
            this.mapping_menu.entries.push({
              name: (idx + 1) + '',
              id: idx
            });
          }
        }
        _ref1 = this.available_mappings;
        _results = [];
        for (idx = _j = 0, _len1 = _ref1.length; _j < _len1; idx = ++_j) {
          mapname = _ref1[idx];
          _results.push(this.mapping_menu.entries.push({
            name: 'new ' + mapname,
            'new': true
          }));
        }
        return _results;
      }
    };

    Dwim.prototype.requestMappingChange = function() {
      var entry, next_mapping, next_mapping_id;
      entry = this.mapping_menu.entries[this.mapping_menu.selected];
      this.mapping_menu = null;
      if (entry['new']) {
        next_mapping_id = this.mappings.length;
        next_mapping = new Mapping(this.mappings.length);
        this.mappings[next_mapping_id] = next_mapping;
      } else {
        next_mapping_id = entry.id;
        next_mapping = this.mappings[next_mapping_id];
      }
      return this.execute({
        type: 'mapping',
        id: next_mapping_id
      });
    };

    Dwim.prototype.doWhatMustBeDone = function() {
      return this.execute(this.translateInstruction(this.currentInstruction()));
    };

    Dwim.prototype.currentInstruction = function() {
      return this.active_program.code.charAt(this.pc);
    };

    Dwim.prototype.translateInstruction = function(instruction) {
      return this.active_mapping.mapCode(instruction);
    };

    Dwim.prototype.isCurrentActionBlank = function() {
      return this.active_program && this.translateInstruction(this.currentInstruction()).type === 'blank';
    };

    Dwim.prototype.execute = function(requested_action) {
      var action, ra;
      ra = requested_action;
      if (this.active_program == null) {
        return false;
      }
      if (ra.type === 'blank') {
        return false;
      }
      action = this.translateInstruction(this.currentInstruction());
      if (action.type !== 'blank' && action.type !== ra.type) {
        return false;
      }
      switch (action.type) {
        case 'move':
          if (this.isMoveAllowed(ra.dir.dx + this.botx, ra.dir.dy + this.boty)) {
            this.botx = this.allowed_move.x;
            this.boty = this.allowed_move.y;
            this.botdir = ra.dir.theta;
          } else {
            return false;
          }
          break;
        case 'mapping':
          if (ra.id === action.id) {
            this.active_mapping = this.mappings[action.id];
          } else {
            return false;
          }
          break;
        case 'blank':
          this.installMapping(this.active_mapping, requested_action, this.currentInstruction());
          this.updateProgram();
          return true;
      }
      this.pc += 1;
      if (this.pc === this.active_program.code.length) {
        this.active_program = null;
        this.active_mapping = null;
      }
      this.updateProgram();
      return true;
    };

    Dwim.prototype.updateProgram = function() {
      var cell;
      cell = this.level[this.botx][this.boty];
      if (cell.type === 'program') {
        if ((this.active_program != null) && this.active_program.code === this.programs[cell.id].code) {
          true;
        } else {
          this.active_program = this.programs[cell.id];
          this.active_mapping = this.mappings[0];
          this.pc = 0;
        }
      }
      if (cell.type === 'exit') {
        this.nextLevelLink();
        this.stop_running = true;
        return;
      }
      this.updateAllowedMove();
      this.showExecutionStatus();
    };

    Dwim.prototype.showExecutionStatus = function() {
      var action, instruction;
      if (this.active_program != null) {
        instruction = this.currentInstruction();
        action = this.translateInstruction(instruction);
        switch (action.type) {
          case 'move':
            if (!this.isMoveAllowed(action.dir.dx + this.botx, action.dir.dy + this.boty)) {
              return this.setError('No valid move');
            } else {
              return this.setStatus('Running Program', 'Input: &lt;enter&gt; to move');
            }
            break;
          case 'mapping':
            return this.setStatus('Running Program', 'Input: &lt;enter&gt; to switch mapping');
          case 'blank':
            return this.setStatus("<span class=\"att\">Need an action for " + instruction_names[instruction] + "</span>", "Input: any direction" + (this.available_mappings.length > 0 ? ', &quot;m&quot; to switch mapping' : ''));
        }
      } else {
        return this.setStatus('Free Running', 'Input: any direction');
      }
    };

    Dwim.prototype.installMapping = function(mapping, action, instruction) {
      var new_action;
      new_action = null;
      switch (action.type) {
        case 'move':
          console.log('install move');
          new_action = new MoveCommand(action.dir);
          break;
        case 'mapping':
          console.log('install mapping');
          new_action = new MappingCommand(action.id);
      }
      return mapping.setMapping(instruction, new_action);
    };

    return Dwim;

  })();

  Mapping = (function() {
    function Mapping(id) {
      this.id = id;
      this.instructions = [];
      this.commands = [];
    }

    Mapping.prototype.mapCode = function(instruction) {
      var idx;
      idx = this.instructions.indexOf(instruction);
      if (idx === -1) {
        return {
          type: 'blank'
        };
      } else {
        return this.commands[idx];
      }
    };

    Mapping.prototype.setMapping = function(instruction, command) {
      var idx;
      idx = this.instructions.indexOf(instruction);
      if (idx === -1) {
        idx = this.instructions.length;
        this.instructions[idx] = instruction;
      }
      return this.commands[idx] = command;
    };

    Mapping.prototype.render = function(ctx, current_instruction) {
      var char, ics, idx, len, ocs, temp_inst, _i, _j, _k, _len;
      ocs = g.outer_command_size;
      ics = g.inner_command_size;
      temp_inst = this.instructions;
      if ((current_instruction != null) && !(__indexOf.call(this.instructions, current_instruction) >= 0)) {
        temp_inst = this.instructions.concat([current_instruction]);
      }
      len = temp_inst.length;
      ctx.save();
      g.setStyle(ctx, g.lined_style);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(ocs * 2, 0);
      ctx.lineTo(ocs * 2, ocs * len);
      ctx.lineTo(0, ocs * len);
      ctx.closePath();
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(ocs, 0);
      ctx.lineTo(ocs, ocs * len);
      ctx.stroke();
      for (idx = _i = 1; 1 <= len ? _i < len : _i > len; idx = 1 <= len ? ++_i : --_i) {
        ctx.beginPath();
        ctx.moveTo(0, ocs * idx);
        ctx.lineTo(ocs * 2, ocs * idx);
        ctx.stroke();
      }
      ctx.save();
      ctx.translate(ocs / 2, ocs / 2);
      for (_j = 0, _len = temp_inst.length; _j < _len; _j++) {
        char = temp_inst[_j];
        g.renderShape(ctx, instruction_names[char], ics / 2);
        ctx.translate(0, ocs);
      }
      ctx.restore();
      ctx.translate(ocs * 3 / 2, ocs / 2);
      for (idx = _k = 0; 0 <= len ? _k < len : _k > len; idx = 0 <= len ? ++_k : --_k) {
        if (idx in this.commands) {
          this.commands[idx].render(ctx);
        } else {
          ctx.save();
          g.setStyle(ctx, g.att_lined_style);
          g.renderShape(ctx, 'question', ics / 2);
          ctx.restore();
        }
        ctx.translate(0, ocs);
      }
      ctx.restore();
      if (current_instruction != null) {
        idx = temp_inst.indexOf(current_instruction);
        ctx.save();
        g.setStyle(ctx, g.lined_style);
        ctx.strokeRect((ocs - ics) / 2, (ocs - ics) / 2 + ocs * idx, ocs * 2 - (ocs - ics), ics);
        ctx.restore();
      }
      ctx.save();
      ctx.translate(-25, 10);
      g.setStyle(ctx, g.lined_style);
      g.renderNumber(ctx, this.id + 1);
      return ctx.restore();
    };

    return Mapping;

  })();

  MoveCommand = (function() {
    function MoveCommand(dir) {
      this.dir = dir;
    }

    MoveCommand.prototype.type = 'move';

    MoveCommand.prototype.render = function(ctx) {
      ctx.save();
      g.setStyle(ctx, g.lined_style);
      g.renderArrow(ctx, this.dir.theta, g.inner_command_size);
      return ctx.restore();
    };

    return MoveCommand;

  })();

  MappingCommand = (function() {
    function MappingCommand(id) {
      this.id = id;
    }

    MappingCommand.prototype.type = 'mapping';

    MappingCommand.prototype.render = function(ctx) {
      ctx.save();
      ctx.translate(-8, -8);
      g.setStyle(ctx, g.lined_style);
      g.renderNumber(ctx, this.id + 1);
      return ctx.restore();
    };

    return MappingCommand;

  })();

  Dwim.UP = UP;

  Dwim.DOWN = DOWN;

  Dwim.LEFT = LEFT;

  Dwim.RIGHT = RIGHT;

  window.Dwim = Dwim;

}).call(this);

//# sourceMappingURL=dwim.map
